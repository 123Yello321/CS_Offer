# 迭代器



# 迭代器失效分析

向容器中添加元素和从容器中删除元素的操作可能会使指向容器元素的迭代器失效，一个失效的迭代器将不再表示任何元素，使用失效的迭代器是一种严重的程序设计错误，很可能引起与使用未初始化指针一样的问题。

## 插入操作

对于顺序容器：

* vector：如果存储空间没有重新分配（扩大存储空间），则指向插入位置之前的元素的迭代器仍有效，但指向插入位置之后元素的迭代器将会失效。如果存储空间被重新分配，则指向容器的迭代器全部失效。
* deque：插入到除首尾位置之外的任何位置都会导致迭代器失效。如果在首尾位置添加元素，指向存在的元素的迭代器不会失效。
* list：指向容器的迭代器（包括尾后迭代器和首前迭代器）仍有效。
* forward_list：指向容器的迭代器（包括尾后迭代器和首前迭代器）仍有效。

对于关联容器：

* [multi]{set,map}：迭代器不受影响，因为底层实现是红黑树；
* unordered_[multi]{set,map}：如果插入操作不导致扩大存储空间，进而重新 hash，那么迭代器不受影响，否则所有的迭代器失效。

## 删除操作

当我们从一个容器中删除元素后，指向被删除元素的迭代器会失效，毕竟这个元素已经被销毁了，对于指向其它元素的迭代器来说，具体如下。

对于顺序容器：

* vector：指向被删元素之前元素的迭代器仍然有效。
* deque：如果在首尾之外的任何位置删除元素，那么指向被删除元素外的其它元素的迭代器也会失效。如果删除 deque 的尾元素，则尾后迭代器也会失效，但其它迭代器不受影响，如果删除首元素，都不受影响。
* list：指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）仍有效。
* forward_list：指向容器其他位置的迭代器（包括尾后迭代器和首前迭代器）仍有效。

对于关联容器：

* [multi]{set,map}：迭代器不受影响，因为底层实现是红黑树；
* unordered_[multi]{set,map}：不受影响

对于容器适配器 stack，queue，priority_queue 来说，它们的迭代器取决于底层实现的容器。

由于向迭代器添加元素和从迭代器删除元素的代码可能会使迭代器失效，因此必须保证每次改变容器的操作之后都正确地`重新定位迭代器`。

## 改变容器的循环操作

添加／删除 容器中元素的循环程序必须考虑迭代器可能失效的问题，程序必须保证每个循环步都更新迭代器。insert 和 erase 操作返回的都是迭代器，可以方便我们更新。下面是一个简单的例子：

    // 删除偶数元素, 复制每个奇数元素
    vector<int> vi = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    auto iter = vi.begin();
    while(iter != vi.end()){
        if(*iter % 2){
            iter = vi.insert(iter, *iter);
            iter += 2;              // 跳过当前元素和插入到它前面的元素
        }
        else{
            iter = vi.erase(iter);  // 删除偶数元素
        }
    }

这里 erase 返回的迭代器指向序列中下一个元素，insert 在给定位置之前插入新的元素，然后返回指向新插入元素的迭代器。

`不要保存 end 返回的迭代器`

每当添加删除vector的元素后，或者在 deque 中首元素之外任何位置添加/删除元素后，原来 end 返回的迭代器总是会失效。因此添加或删除元素的循环程序必须反复调用 end。（通常 C++ 标准库的实现中 end() 操作都很快，部分就是因为这个原因）

# 参考  

C++ Primer 9.3.6  
[Iterator invalidation rules](http://stackoverflow.com/questions/6438086/iterator-invalidation-rules)  
[STL的erase()陷阱-迭代器失效总结](http://blog.csdn.net/lanbing510/article/details/8796048)

       

