共享内存就是允许两个不相关的进程访问同一个逻辑内存。共享内存是在两个正在运行的进程之间共享和传递数据的一种最有效的方式，不同进程之间共享的内存通常安排为同一段物理内存。进程可以将同一段共享内存连接到它们自己的地址空间中，所有进程都可以访问共享内存中的地址，就好像它们是由用C语言函数malloc分配的内存一样。而如果某个进程向共享内存写入数据，所做的改动将立即影响到可以访问同一段共享内存的任何其他进程。

# 共享内存接口

Linux中提供了一组函数接口用于使用共享内存，声明在头文件 `sys/shm.h`中。

`shmget函数` 用来创建共享内存，它的原型为：

    int shmget(key_t key, size_t size, int shmflg); 
参数说明如下：

* key 为共享内存段命名，成功时返回一个与key相关的共享内存标识符（非负整数），用于后续的共享内存函数，调用失败返回-1。
* size以字节为单位指定需要共享的内存容量。
* shmflg是权限标志，它的作用与open函数的mode参数一样，如果要想在key标识的共享内存不存在时，创建它的话，可以与IPC_CREAT做或操作。共享内存的权限标志与文件的读写权限一样，举例来说，0644,它表示允许一个进程创建的共享内存被内存创建者所拥有的进程向共享内存读取和写入数据，同时其他用户创建的进程只能读取共享内存。

`shmat函数`用来启动对该共享内存的访问，并把共享内存连接到当前进程的地址空间。因为创建完共享内存时，还不能被任何进程访问。调用成功时返回一个指向共享内存第一个字节的指针，如果调用失败返回-1。它的原型如下：

    void *shmat(int shm_id, const void *shm_addr, int shmflg);  

参数说明如下：

* shm_id是由shmget函数返回的共享内存标识。
* shm_addr指定共享内存连接到当前进程中的地址位置，通常为空，表示让系统来选择共享内存的地址。
* shm_flg是一组标志位，通常为0。

shmdt函数用于将共享内存从当前进程中分离，调用成功时返回0，失败时返回-1。注意，将共享内存分离并不是删除它，只是使该共享内存对当前进程不再可用。它的原型如下：

    int shmdt(const void *shmaddr); 

其中参数shmaddr是shmat函数返回的地址指针。

`shmctl函数`用来控制共享内存，它的原型如下：

    int shmctl(int shm_id, int command, struct shmid_ds *buf); 

主要参数如下：

* shm_id是shmget函数返回的共享内存标识符。
* command是要采取的操作，它可以取下面的三个值 ：
    * IPC_STAT：把shmid_ds结构中的数据设置为共享内存的当前关联值，即用共享内存的当前关联值覆盖shmid_ds的值。
    * IPC_SET：如果进程有足够的权限，就把共享内存的当前关联值设置为shmid_ds结构中给出的值
    * IPC_RMID：删除共享内存段
* buf是一个结构指针，它指向共享内存模式和访问权限的结构。

# 实例分析

下面以两个不相关的进程来说明进程间如何通过共享内存来进行通信。其中shmread.c创建共享内存，并读取其中的信息，shmwrite.c向共享内存中写入数据。为了方便操作和数据结构的统一，为这两个文件定义了相同的数据结构，定义在文件shmdata.c中。结构shared_use_st中的written作为一个可读或可写的标志，非0：表示可读，0表示可写，text则是内存中的文件。


# ipcs 命令
可以使用ipcs命令把共享内存/信号量/消息队列的信息打印出来，如果只想显示共享内存信息，则使用`ipcs -m`。




（共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段最大限制是多少？）


