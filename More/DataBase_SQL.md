

## 事务

事务是一组原子性的 SQL 查询，事务内的语句要么全部执行成功，要么全部执行失败。事务由 begin transaction 和 end transaction 之间执行的全体操作组成，这些步骤集合必须作为一个单一的、不可分割的单元出现。

事务具有一下特征（ACID）：

* 原子性（Atomicity）：事务中所有操作要么全部提交成功，要么全部失败回滚。对事务来说，不可能只执行其中的一部分。
* 一致性（Consistency）：数据库总是从一个一致的状态转换到另一个一致的状态。
* 隔离性（Isolation）：一个事务所做的修改在最终提交之前，对其它事务是不可见的。因此，每个事务都感觉不到系统中有其它事务在并发地执行。
* 持久性（Durability）：一旦事务提交，其所做的修改就会永久保存到数据库中。此时，即使系统崩溃，修改的数据也不会丢失。

SQL标准中定义了4种隔离级别，每一个级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。较低级别的隔离通常可以执行更高地并发，系统的开销也更低。

* READ UNCOMMITED（未提交读）：事务中的修改，即使没有提交，对其它事务也都是可见的。可能发生`脏读`：即事务可以读取未提交的数据。（实际中很少使用）
* READ COMMITTED（提交读）：满足事务隔离性的简单定义：一个事务开始时，只能看见已经提交的事务所做的修改。这个级别有时候也叫做`不可重复读`，因为事务两次读取一个数据项期间，另一个事务更新了该数据并提交。大多数数据库系统的默认隔离级别是 READ COMMITTED（但是MySQL不是）
* REPEATABLE READ（可重复读）：只允许读取已经提交的数据，而且在一个事务两次读取一个数据项期间，其它事务不得更新该数据。但该事务不要求和其它事务可串行化。可能存在`幻读`问题：当某个事物在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。可重复读是 MySQL 的默认事务隔离级别。
* SERIALIZABLE（可串行化）：最高的隔离级别，通过强制事务串行执行，避免前面的幻读问题。会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。

隔离级别与避免的问题如下表所示：

| 隔离级别 | 脏读可能性 | 不可重复读可能性 | 幻读可能性 |
|---------|----------|---------------|-----------|
|READ UNCOMMITED | ✔︎ | ✔︎ | ✔︎ |
|READ COMMITTED  | ✘ | ✔︎ | ✔︎ |
|REPEATABLE READ | ✘ | ✘ | ✔︎ |
|SERIALIZABLE    | ✘ | ✘ | ✘ |

［[允许不可重复读的隔离级别](http://www.nowcoder.com/questionTerminal/d843add07bfd480dbfe1c5401490a411)］  

参考  
[脏读、幻读和不可重复读 + 事务隔离级别](http://uule.iteye.com/blog/1109647)  

## 视图

让所有用户都看到整个逻辑模型是不合适的，此外有时候希望创建一个比逻辑模型更符合特定用户直觉的个人化的关系集合。因此，SQL 允许通过查询来定义`虚关系`，它在概念上包含查询的结果。虚关系并不预先计算并存储，而是在使用虚关系的时候才通过执行查询进行计算。任何像这种不是逻辑模型的一部分，但作为虚关系对用户可见的关系称为`视图`（View）。

SQL 中用 create view 命令来定义视图，为了定义视图，必须给它一个名称，并提供计算视图的查询，如下格式：

    create view v as <query expression>;

一旦定义了一个视图之后，可以用视图名指代视图生成的虚关系。在查询中，视图名可以出现在关系名可以出现的任何地方。视图关系出现在查询中时，实际上已经被存储的查询表达式代替，因此，无论何时执行这个查询，视图关系都会被重新计算。

此外，**一个视图可以被用到定义另一个视图的表达式中**。

### 视图更新

对查询来说，视图时一个有用的工具，但是如果用它们来表达更新、插入或者删除，可能会带来严重的问题。困难在于，用视图表达的数据库修改必须被翻译为对数据库逻辑模型中实际关系的修改。因此，除了一些有限的情况外，一般不允许对视图关系进行更新。

不同的数据库系统指定了不同的条件以允许更新视图关系。一般来说，如果定义的视图查询对下列条件都满足，则称 SQL 视图是可更新的（即视图上可以执行插入、更新或删除）。

* from 子句中只有一个数据库关系
* select 子句中只包含关系的属性名，不包含任何表达式、聚集或 distinct 声明
* 任何没有出现在 select 子句中的属性可以取空值，即这些属性没有 not null 约束，也不构成主码的一部分
* 查询中不含有 group by 或 having 子句。

## 完整性约束

完整性约束保证授权用户对数据库所做的修改不会破坏数据的一致性，防止对数据的意外破坏。完整性约束通常被看作是数据库模式设计过程的一部分，作为用于创建关系的一部分被声明。比如下面的例子：

* 教师名不能为 null
* 任意两位教师不能有相同的教师标识
* 一个系的预算必须大于 0.00 美元

允许的完整性约束有

* not null 约束：声明在属性上禁止插入空值；
* unique 约束：unique(A<sub>1</sub>, A<sub>2</sub>,..., A<sub>n</sub>) 声明指出属性 A<sub>1</sub>, A<sub>2</sub>,..., A<sub>n</sub> 形成了一个候选码。注意候选码属性可以为 null（除非显式地声明为 not null）。
* check 字句：check(p) 字句指定谓词 p，关系中的每个元组必须满足谓词p，这里 p 可以是包含子查询在内的任意谓词。
* `参照完整性约束`：保证一个关系中给定属性集上的取值也在另一关系的特定属性集的取值中出现。（外码约束）

［[检查约束实现](http://www.nowcoder.com/questionTerminal/1a7e237c89ba4ec39545e90647588a58)］  

## 触发器

触发器是一种特殊的存储过程，它在插入，删除或修改特定表中的数据时触发执行，它比数据库本身标准的功能有更精细和更复杂的数据控制能力。注意事项：

1. 只有表才可以支持触发器，视图和临时表都不支持触发器
2. 每个表的每个事件只支持一个触发器，因此每个表最多支持6个触发器
3. 单一触发器不能与多个操作相关
4. 触发器不能更新和覆盖，如果想更新一个触发器必须先删除，再创建



# 更多阅读

《高性能Mysql》  
《数据库系统概念》  

