
# 关系模型

关系数据库由表的集合构成，每个表有唯一的名字。表中一行代表了一组值之间的一种联系。

在关系模型的术语中，关系(relation)用来指代表，而元组(tuple)用来指代行，属性(attribute)指表中的列。关系实例(relation instance)表示一个关系的特定实例，也就是所包含的一组特定的行。对于关系的每个属性，都存在一个允许取值的范围，称为该属性的域(domain)。

数据库模式(database schema)：数据库的逻辑设计，数据库实例(database instance)：给定时刻数据库中数据的一个快照。

`查询语言`是用户用来从数据库中请求获取信息的语言，可以分为过程化语言和非过程化语言。过程化语言中，用户指导系统对数据库进行一系列操作以计算出所需结果；非过程化语言中，用户只需描述所需信息，而不用给出获取该信息的具体过程。

## 码

一个关系中没有两个元组在所有属性上的值相同，因此一个元组的属性值必须要能够唯一区分元组。

`超码`（super key）是一个或者多个属性的集合，这些属性的集合能够唯一地标识一个关系中的一个元组。超码中可以包含无关紧要的属性，如果 k 是一个超码，那么 k 的任意超集也是超码。

`候选码`（candidate key）：任意真子集都不能成为超码的超码，也即最小超码。有可能有多个不同的属性集都可以做候选码。

`主码`（primary key）：被数据库设计者选中的，主要用来在一个关系中区分不同元组的候选码。主码的选择必须慎重，应该选择那些值从来不变或者极少变化的属性。

码是整个关系的一种性质，而不是单个元组的性质。码的指定代表了被建模的事物在现实世界中的约束。

此外，一个关系模式（如r1）可能在它的属性中包括另一个关系模式（如r2）的主码，这个属性在r1上称作参照r2的`外码`（foreign key）。

## 关系代数

关系代数是一种过程化查询语言，包括一个运算的集合。这些运算以一个或者两个关系作为输入，产生一个新的关系作为结果。关系代数的基本运算有：选择、投影、并、集合差、笛卡尔积和更名。在基本运算外，还有一些其它运算，即集合交、自然连接和赋值。

| 基本关系运算 |          解释       |
|------------|--------------------|
|  选择 σ   | 选择从关系的水平方向进行元算，选择满足给定条件的元组组成新的关系  | 
|  投影 π   | 从关系的垂直方向开始运算，选择关系中的若干列组成新的列          |
|    并    | R,S 具有相同的关系模式，RUS 为属于R或者S的元组|
|  集合差  | R,S 具有相同的关系模式，R-S为属于R但不属于S的元组 |
|  笛卡儿积 | 从两个输入关系中输出所有的元组对（无论它们在共同属性上的取值是否相同）  |
| 更名 ρ  | 将更名运算运用于关系 r，得到一个具有新名字的相同关系 |

### 附加的关系代数运算

通过定义一些附加的运算，虽然不能增强关系代数的表达能力，却可以简化一些常用的查询。

|附加关系运算 |          解释       |
|------------|--------------------|
|集合交运算   | R,S具有相同的关系模式，R∩S=R-(R-S) |
|自然连接 ⋈  |  R⋈S 的结果是在R和S中的在它们的公共属性名字上相等的所有元组的组合。 |
| 赋值运算 ←| 类似程序语言中的赋值，将 ← 右侧的表达式的结果赋给左侧的关系变量，该关系变量可以在后续的表达式中使用  |
| 左外链接 ⟕ | R ⟕ S，包含R中所有元组，对每个元组，若在S中有在公共属性名字上相等的元组，则正常连接，若在S中没有在公共属性名字上相等的元组，则依旧保留此元组，并将对应其他列设为NULL |
| 右外链接 ⟖ | R ⟖ S，外连接的结果包含S中所有元组，对每个元组，若在R中有在公共属性名字上相等的元组，则正常连接，若在R中没有在公共属性名字上相等的元组，则依旧保留此元组，并将对应其他列设为NULL。 |
| 全外链接 ⟗ | R ⟗ S，全外连接的结果包含R与S中所有元组，对每个元组，若在另一关系上中有在公共属性名字上相等的元组，则正常连接，若在另一关系上中没有在公共属性名字上相等的元组，则依旧保留此元组，并将对应其他列设为NULL。|

# SQL

SQL 是使用最为广泛的查询语言，有以下几个部分：

* 数据定义语言（DDL）：提供定义、删除、修改关系模式的命令；
* 数据操纵语言（DML）：提供从数据库中查询信息，一集在数据库中插入、删除、修改元组的能力；
* 完整性（Integrity）：定义完整性约束的命令
* 视图定义（View definition）：定义视图的命令
* 事物控制（transaction control）：定义事务的开始和结束的命令
* 嵌入式SQL和动态SQL：定义SQL语句如何嵌入到通用编程语言中
* 授权：定义对关系和视图的访问权限的命令


## SQL 查询基本结构

SQL 查询基本结构由三个子句构成：select、from 和 where，查询的输入是在 from 子句中列出的关系，在这些关系上进行 where 和 select 子句中指定的运算，然后产出一个关系作为结果。


多表连接没有指定连接条件时，对应集合的笛卡尔积连接。

［[多表查询笛卡尔积](http://www.nowcoder.com/questionTerminal/686aa444c67b4f0c9ca774a50caa494a)］  

### 附加的基本运算

`字符串运算`：在字符串上可以使用`like 操作符`来实现模式匹配（大小写敏感）。

* `百分号%`：匹配任意字串
* `下划线_`：匹配任意一个字符

为了使模式中包含特殊模式的字符（％，_），SQL允许转义字符。在like比较运算中使用 escape 关键词来定义转义字符。如下例子：

* like 'ab\%cd%' escape '\': 匹配所有以 'ab%cd' 开头的字符串；
* like '[8,6]_0%'：匹配第一位为8或6，第三位为0的字符串；

所以要查找 student表中所有电话号码(列名：telephone)的第一位为8或6，第三位为0的电话号码，用下面语句即可：

    SELECT telephone FROM student WHERE telephone LIKE ‘[8,6]_0%’

［[查找倒数第三个字符为W](http://www.nowcoder.com/questionTerminal/87a000d6b34d4c82be56d17ad2945a60)］

## 聚集函数

GroupBy语句从英文的字面意义上理解就是“根据(by)一定的规则进行分组(Group)”。它的作用是通过一定的规则将一个数据集划分成若干个小的区域，然后针对若干个小区域进行数据处理。

［[Group By子句作用](http://www.nowcoder.com/questionTerminal/a1403ec16dc245ebbed0f88f7479dd92)］  

标准的 SQL 的解析顺序为: 

1. FROM 子句, 组装来自不同数据源的数据
2. WHERE 子句, 基于指定的条件对记录进行筛选
3. GROUP BY 子句, 将数据划分为多个分组
4. 使用聚合函数进行计算
5. 使用 HAVING 子句筛选分组
6. 计算Select所有的表达式
7. 使用 ORDER BY 对结果集进行排序

［[分组后满足指定条件的查询](http://www.nowcoder.com/questionTerminal/a42d4a67d0b0471a8dfd7e9b3892afee)］  

## 数据库的修改

SQL 支持对数据库的修改操作，包括删除、更新、插入操作。这些操作都可以用 where 指定谓语，where 子句可以包含 select 语句的 where 子句中的任何合法结构（包括嵌套的select）。**where 语句中嵌套的select可以引用待更新的关系**。

### 删除

只能删除整个元组，而不能只删除某些属性上的值。

> delete from r  
> where P;

其中 P 代表一个谓词，r代表一个关系。delete 语句首先从 r 中找出所有使P(t)为真的元组，然后把它们从 r 中删除。如果省略where子句，则r中所有元组将被删除。

delete 请求可以引用包含嵌套的select，该 select 引用待删除元组的关系。假如想删除工资低于大学平均工资的教师记录，可以写出如下语句：

    delete from instructor
    where salary < (select avg(salary)
                    from instructor);

该 delete 语句首先测试 instructor 关系中的每一个元组，检查其工资是否小于大学教师的平均工资，然后再删除所有符合条件的元组。注意，这里在**执行任何删除之前先进行所有元组的测试**至关重要。

### 插入

要往关系中插入数据，可以指定待插入的元组，或者写一条查询语句来生成待插入的元组集合。必须保证待插入元组的属性值必须在相应属性的域中。insert 语句中可以指定属性，也可以不指定，不指定属性时，插入值的排序和关系模式中属性排列的顺序一致。

    insert into course
        values('CS-437','Database System', 'Comp. Sci', 4);
        
    insert into course(course_id, title, dept_name, credits)
        values('CS-437','Database System', 'Comp. Sci', 4);
        
    insert into course(title, course_id, dept_name, credits)
        values('Database System', 'CS-437', 'Comp. Sci', 4);

### 更新

update 语句可以在不改变整个元组的情况下改变其部分属性的值。假如要进行年度工资增长，如下：

    update instructor
    set salary=salary*1.5

上面更新语句将在instructor关系的每个元组上执行一次。update 语句中嵌套的 select 语句可以引用待更新的关系，对工资低于平均工资的教师涨 5% 的工资，可以写成如下形式：

    update instructor
    set salary=salary*1.05
    where salary < (select avg(salary)
                    from instructor);

SQL 语句提供case 语句，可以利用它在一条语句中执行多种更新，避免更新次序发生的问题。

    update instructor
    set salary=case
        when salary = 7000 then salary * 1.05
        when salary < 7000 then salary * 1.15
        else salary * 1.03
        end

SQL 的更多高级内容参见 [DataBase_SQL.md](More/DataBase_SQL.md)

# 关系数据库设计

一般而言，关系数据库设计的目标是生成一组关系模式，使我们存储信息时避免不必要的冗余，并且可以让我们方便地获取信息。这是通过设计满足适当范式（normal form）的模式来实现的。

## 原子域和第一范式

一个域是原子的，如果该域的元素被认为是不可分的单元。如果 R 的所有属性的域都是原子的，则称关系模式 R 属于第一范式。

仅仅符合1NF的设计，会存在数据冗余过大，插入异常，删除异常，修改异常的问题，例如下表中的设计：

![][1]

存在着下面的问题：

* `数据冗余过大`：每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次。
* `插入异常`：假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的。
* `删除异常`：假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。
* `修改异常`：假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据。

因为仅符合1NF的数据库设计存在着这样那样的问题，我们需要提高设计标准，去掉导致上述四种问题的因素，使其符合更高一级的范式（2NF）。

## 第二范式

第二范式在第一范式的基础上，消除了`非主属性对于候选码的部分函数依赖`。

若在一张表中，**在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说 Y 函数依赖于 X，写作 X➞Y**。也就是说，在数据表中，不存在任意两条记录，它们在X属性（或属性组）上的值相同，而在Y属性上的值不同。这也就是“函数依赖”名字的由来，类似于函数关系 y = f(x)，在x的值确定的情况下，y的值一定是确定的。

例如，对于表3中的数据，找不到任何一条记录，它们的学号相同而对应的姓名不同。所以我们可以说姓名函数依赖于学号，写作“学号 ➞ 姓名”。

从“函数依赖”这个概念展开，还会有三个概念：

* `完全函数依赖`：在一张表中，若 X➞Y，且对于X的任何一个真子集（假如属性组X包含超过一个属性的话）X'➞Y 不成立，那么我们称Y对于X完全函数依赖。
* `部分函数依赖`：假如Y函数依赖于X，但同时Y并不完全函数依赖于X，那么我们就称Y部分函数依赖于X。
* `传递函数依赖`：假如Z函数依赖于Y，且Y函数依赖于X （严格来说还有一个X不包含于Y，且Y不函数依赖于Z的前提条件），那么我们就称 Z 传递函数依赖于X。

包含在任何一个候选中的属性称为主属性。如果数据表中存在`非主属性`对于候选码的部分函数依赖，则数据表不符合 2NF 的要求，否则，符合2NF。

对于上面的表，所有的函数依赖关系如下图：

![][2]

候选码为（学号，课名），主属性为（学号，课名），其它属性为非主属性。对于（学号，课名）➞姓名，有学号➞姓名，存在非主属性`姓名`对于候选码的部分函数依赖；同理还存在非主属性`系名，系主任`对于候选码的部分函数依赖。

为了使上面表格符合 2NF 要求，必须消除这些部分函数依赖。通过将大数据表拆分成两个或者多个更小的表。将数据表拆分，达到更高一级范式要求的过程，叫做`模式分解`，模式分解的结果并不唯一，下面是一种分解结果：

1. 选课表（ _学号，课名_，分数）  
2. 学生 （ _学号_，姓名，系名，系主任）

新的数据表格如下：

![][4]

满足 2NF 后，之前的问题

* 数据冗余减少
* 李小明转系到法律系，只需要更改一次，有改进。
* `插入异常`：学生表候选码是学号，所以插入没有学生的系失败。
* `删除异常`：假如将某个系中所有学生相关的记录都删除，那么系与系主任的数据也就随之消失了。

## 第三范式

3NF 在 2NF 的基础上，消除了`非主属性对于候选码的传递函数依赖`。也就是说如果存在非主属性对于候选码的传递函数依赖，则不符合3NF的要求。

对于上面满足2NF的表，函数依赖关系如下图：

![][3]

对于选课表，满足3NF。对于学生表，存在有传递函数依赖，学号➞系名，系名➞系主任，因此不符合 3NF。

为了让数据表设计达到 3NF，必须进一步进行模式分解如下：

1. 选课表（ _学号，课名_，分数）  
2. 学生 （ _学号_，姓名，系名） 
3. 系（ _系名_，系主任）

新的数据表如下：

![][5]

满足3NF后情况有了很大的改观，基本上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。

## BCNF 范式

在 3NF 的基础上，消除了`主属性对于候选码的部分函数依赖与传递函数依赖`。

具体看下面的一个示例，某公司有若干个仓库，其中：

* 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
* 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。

容易知道函数依赖集：仓库名➞管理员，管理员➞仓库名，（仓库名，物品名）➞数量，候选码有两个，分别是（`管理员，物品名`），（`仓库名，物品名`））。主属性：仓库名、管理员、物品名，非主属性：数量。

所以不存在非主属性对候选码的部分函数依赖和传递函数依赖，此关系模式属于3NF。基于此关系模式的关系（具体的数据）可能如图所示：

![][6]

那么这个关系模式是否存在问题呢？我们来看以下几种操作：

* 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。
* 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。

从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着插入异常，修改异常与删除异常的问题，仍然不是好的设计。

造成此问题的原因：存在着主属性对于候选码的部分函数依赖与传递函数依赖。在此例中就是存在主属性【仓库名】对于候选码（管理员，物品名）的部分函数依赖。

解决办法就是要在 3NF 的基础上消除主属性对于候选码的部分函数依赖与传递函数依赖。如下：

* 仓库（仓库名，管理员）
* 库存（仓库名，物品名，数量）

## 范式还是反范式

在范式化的数据库中，每个事实数据出现并且只出现一次。相反，在反范式化的数据库中，信息是冗余的，可能会存储在多个地方。

范式化设计的好处：

* 范式化的更新操作通常比反范式化要快；
* 当数据较好地范式化时，就只有很少或者没有重复数据，所以只需要更改更少的数据；
* 范式化的表通常更小，可以更好地放在内存中，所以执行操作会快；

范式化设计的一个缺点是通常需要关联，稍微复杂一些的查询语句在符合范式的 schema 上都可能需要至少一次关联。不但代价昂贵，也可能使一些索引策略无效。

反范式化的 schema 因为所有数据都放在一张表中，可以很好地避免关联。单独的表也能使用更有效的索引策略。

实际应用中，可以使用部分 schema、缓存表等技巧。最常见的反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。在新版本的Mysql中，可以使用触发器更新缓存值。

# 索引与散列

## 索引技术

索引类型分类

* 主索引：主索引是一种只能在数据库表中建立不能在自由表中建立的索引。在指定的字段或表达式中，主索引的关键字绝对不允许有重复值。
* 候选索引：和主索引类似，它的值也不允许在指定的字段或表达式中重复。一个表中可以有多个候选索引。
* 唯一索引：唯一索引允许关键字取重复的值。当有重复值出现时，索引文件只保存重复值的第1次出现。提供唯一索引主要是为了兼容早期的版本。
* 普通索引：普通索引允许关键字段有相同值。在一对多关系的多方，可以使用普通索引。

索引可以包含一个、两个或更多个列。两个或更多个列上的索引被称作复合索引。对索引中的所有列执行搜索或仅对前几列执行搜索时，复合索引非常有用；仅对后面的任意列执行搜索时，复合索引则没有用处。

应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描。

［[索引字段不唯一](https://www.nowcoder.com/questionTerminal/1fbc72e6a9964221ab1f8bb674775869)］  
［[不能使用索引，执行速度最慢的语句](http://www.nowcoder.com/questionTerminal/e3bdb7479ace47bd900816726549d48b)］  
［[执行效率最高的搜索语句](http://www.nowcoder.com/questionTerminal/af0b24bb3e6241c4992a0d8e7b79fc85)］  

## 主键、外键

关系型数据库中的一条记录中有若干个属性，若其中某一个`属性组`(注意是组)能唯一标识一条记录，该属性组就可以成为一个主键。比如下面的三个表中（主键用下划线标注）。

* 学生表( _学号_ ，姓名，性别，班级) 
* 课程表( _课程编号_ ，课程名，学分) 
* 成绩表( _学号，课程号_ ，成绩)

其中每个学生的学号是唯一的，学号就是一个主键。其中课程编号是唯一的，课程编号就是一个主键。成绩表中单一一个属性无法唯一标识一条记录，学号和课程号的组合才可以唯一标识一条记录，所以学号和课程号的属性组是一个主键。

成绩表中的学号不是成绩表的主键，但它和学生表中的学号相对应，并且学生表中的学号是学生表的主键，则称成绩表中的学号是学生表的`外键`。同理成绩表中的课程号是课程表的外键。外键用于与另一张表的关联，是能确定另一张表记录的字段，用于保持数据的一致性。

主键主要有两个用途：

1. 惟一地标识一行。
2. 作为一个可以被外键有效引用的对象。



［[候选关键字](http://www.nowcoder.com/questionTerminal/088587c25467478884128c0cb31eeeb8)］  
［[主键、外键](http://www.nowcoder.com/questionTerminal/70100692594e4130a6b3efe344ef3874)］  

# Mysql 常用命令


# 高级主题

［[事物并发丢失修改](http://www.nowcoder.com/questionTerminal/ea4505062668488c8048a82368e3d9e2)］  

数据库中有可能会存在不一致的数据。造成数据不一致的原因主要有：

* `数据冗余`: 如果数据库中存在冗余数据，比如两张表中都存储了用户的地址，在用户的地址发生改变时，如果只更新了一张表中的数据，那么这两张表中就有了不一致的数据。
* `并发控制不当`: 比如某个订票系统中，两个用户在同一时间订同一张票，如果并发控制不当，可能会导致一张票被两个用户预订的情况。当然这也与元数据的设计有关。
* `故障和错误`: 如果软硬件发生故障造成数据丢失等情况，也可能引起数据不一致的情况。因此我们需要提供数据库维护和数据恢复的一些措施。

# 更多阅读

《高性能Mysql》  
《数据库系统概念》  
[解释一下关系数据库的第一第二第三范式？](https://www.zhihu.com/question/24696366)  

[1]: http://7xrlu9.com1.z0.glb.clouddn.com/DatabaseSystem_1.png
[2]: http://7xrlu9.com1.z0.glb.clouddn.com/DatabaseSystem_2.png
[3]: http://7xrlu9.com1.z0.glb.clouddn.com/DatabaseSystem_3.png
[4]: http://7xrlu9.com1.z0.glb.clouddn.com/DatabaseSystem_4.png
[5]: http://7xrlu9.com1.z0.glb.clouddn.com/DatabaseSystem_5.png
[6]: http://7xrlu9.com1.z0.glb.clouddn.com/DatabaseSystem_6.png

