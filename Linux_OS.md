
# Linux、OS 知识
# 常用命令

系统

* uname -a   # 查看内核/操作系统/CPU信息
* hostname   # 查看计算机名
* env        # 查看环境变量
* uptime     # 查看系统运行时间、用户数、负载

资源

* free       # 查看内存使用量和交换区使用量
* df -h      # 查看各分区使用情况
* top        # 实时显示进程状态
* ps         # 系统中当前运行的那些进程
* ipcs       # 进程间通信

网络

* ifconfig     # 查看所有网络接口的属性
* iptables -L  # 查看防火墙设置
* route -n     # 查看路由表
* netstat -s   # 查看网络统计信息
* ss           # netstat 的替代
* tcpdump      # 用来抓包

任务

* ctrl + z       # 可以将一个正在前台执行的命令放到后台，并且暂停
* jobs           # 查看当前有多少在后台运行的命令
* fg %jobnumber  # 将后台中的命令调至前台继续运行（%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)）
* bg %jobnumber # 将一个在后台暂停的命令，变成继续执行。

`netstat`：用来显示相关的网络信息，如接口/网卡状态(-i)，路由表(-r)，网络连接(-a)，tcp相关选项(-t)，udp相关选项(-u)，按各个协议统计(-s)。

`top`：在系统维护的过程中，随时可能有需要查看 CPU 使用率，并根据相应信息分析系统状况的需要。运行 top 命令后，CPU 使用状态会以全屏的方式显示，并且会处在对话的模式，此时用基于 top 的命令，可以控制显示方式。退出 top 的命令为 q。

`ipcs`：Linux下显示进程间通信设施状态的工具。可以显示消息队列、共享内存和信号量的信息。

参考  
[工具参考篇](http://linuxtools-rst.readthedocs.org/zh_CN/latest/tool/index.html)

# 操作系统概念

`单道批处理系统`：系统对作业的处理是成批进行的，但内存中始终只保持一道作业。当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。

`多道批处理系统`：多道程序设计技术允许多个程序同时进入内存并运行。即同时把多个程序放入内存，并允许它们交替在CPU中运行，它们共享系统中的各种硬、软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。它没有用某些机制提高某一技术方面的瓶颈问题，而是让系统的各个组成部分都尽量去“忙”，花费很少时间去切换任务，达到了系统各部件之间的并行工作，使其整体在单位时间内的效率翻倍。

`分时操作系统`：把处理器的运行时间分成很短的时间片，按时间片轮流把处理器分配给各联机作业使用。若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得很快，给每个用户的感觉好像是自己独占一台计算机。多道批处理是实现作业自动控制而无需人工干预的系统，而分时系统是实现人机交互的系统。

`实时操作系统`：为了能在某个时间限制内完成某些紧急任务而不需时间片排队，诞生了实时操作系统。在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且要在严格的时限内处理完接收的事件。实时橾作系统的主要特点是及时性和可靠性。

参考  
[操作系统的发展与分类](http://c.biancheng.net/cpp/html/2582.html)  

# 进程与线程

并发和并行的区别就是一个处理器同时处理多个任务和多个处理器或者是多核的处理器同时处理多个不同的任务。前者是逻辑上的同时发生，而后者是物理上的同时发生．

* 并发(concurrent)：指能处理多个同时性活动的能力，并发事件之间不一定要同一时刻发生。
* 并行(parallel)：指同时发生的两个并发事件，具有并发的含义，而并发则不一定并行。

![][1]

［[fork 输出个数](http://www.nowcoder.com/questionTerminal/1f6cc9c0ef354f86b1727c6c030a1a19)］  
［[进程和线程描述](http://www.nowcoder.com/questionTerminal/686a6b91356042cab35d7429b4e86547)］  
［[线程共享的资源](http://www.nowcoder.com/questionTerminal/e77f38359f074676b7f6f6e981c71cce)］  
［[线程并发脏数据](http://www.nowcoder.com/questionTerminal/532ddd8c34e84eaab24c6538b8091445)］  
［[进程轮询调度周转时间](http://www.nowcoder.com/questionTerminal/1469627261884cd3ac5755a49a46d8f9)］  

关于进程的更多内容参见 [Linux_OS_ProcessThread.md](More/Linux_OS_ProcessThread.md)  

## 守护进程

`守护进程`，也即通常所说的 Daemon 进程，是 Linux 下一种特殊的后台服务进程，它独立于控制终端并且周期性的执行某种任务或者等待处理某些发生的事件。守护进程通常在系统引导装入时启动，在系统关闭时终止。Linux 系统下大多数服务都是通过守护进程实现的，守护进程的名称通常以 d 结尾，如 httpd、crond、mysqld等。

守护进程首要的特性是后台运行；其次，要与从启动它的父进程的运行环境隔离开来，需要处理的内容大致包括会话、控制终端、进程组、文件描述符、文件权限掩码以及工作目录等。

守护进程可以在 Linux 启动时从脚本 /etc/rc.d 启动，也可以由作业规划进程 crond 启动，还可以通过用户终端（一般是 Shell）启动。实现一个守护进程，其实就是将普通进程按照上述特性改造为守护进程的过程。

从终端 Shell 启动守护进程的步骤如下：

1. 创建子进程，父进程退出
2. 子进程创建新会话
3. 改变当前工作目录
4. 重设文件权限掩码
5. 关闭文件描述符

守护进程的详细内容参见 [Linux_OS_Daemon.md](more/Linux_OS_Daemon.md).

## 僵尸、孤儿进程

子进程先于父进程结束，而且父进程没有函数调用 wait() 或 waitpid() 等待子进程结束，也没有注册 SIGCHLD 信号处理函数，结果使得子进程的进程列表信息无法回收，这样子进程就变成了`僵尸进程（Zombie）`。

所以简单**来说一个已经终止，但是其父进程尚未对其进行善后处理**（终止子进程的有关信息）的进程被称为僵尸进程。

UNIX 提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息，就可以得到。这种机制就是: 在每个进程(init除外)退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留一定的信息（包括进程号PID，退出状态，运行时间等)，直到父进程通过wait/waitpid 来取时才释放。

如果父进程不调用wait/waitpid的话，那么保留的那段信息就不会释放，其进程号就会一直被占用（这时用ps命令就能看到子进程的状态是“Z”），但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程。此即为僵尸进程的危害，应当避免。

注意如果父进程先于子进程结束，这时的子进程应该称作`孤儿进程（Orphan）`。每当出现一个孤儿进程的时候，内核就把孤儿进程的父进程设置为init，而init进程会循环地调用wait()。这样，当一个孤儿进程结束其生命周期后，init进程就会进行善后工作。因此孤儿进程并不会有什么危害。

参考： [孤儿进程与僵尸进程](http://www.cnblogs.com/Anker/p/3271773.html)

# 存储管理

## C/C++ 程序的存储空间分布

C 程序由下列几部分组成：

1. 正文(text)段：正文段是用来存放可执行文件的操作指令，也就是说是它是可执行程序在内存中的镜像。代码段需要防止在运行时被非法修改，所以只准许读取操作，而不允许写入（修改）操作——它是不可写的。
2. 数据段：初始化数据段包含程序中需明确地赋初值的变量，例如初始化后的全局变量和静态局部变量。
3. BSS段（未初始化数据段）：BSS段包含了程序中未初始化的全局变量，程序开始执行前，内核将此段中的数据初始化为0或者空指针。
4. 堆（heap）：堆是用于存放进程运行中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到堆上（堆被扩张）；当利用free等函数释放内存时，被释放的内存从堆中被剔除（堆被缩减）
5. 栈：栈是用户存放程序临时创建的局部变量，也就是说我们函数括弧“{}”中定义的变量（但不包括static声明的变量，static意味着在数据段中存放变量）。除此以外，在函数被调用时，其参数也会被压入发起调用的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中。由于栈的后进先出特点，所以栈特别方便用来保存/恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存、交换临时数据的内存区。

下图显示了这些段的一种典型安排方式：

![][2]

## 内存堆与栈

堆和栈是两种内存分配的两个统称。可能有很多种不同的实现方式，但是实现要符合几个基本的概念:

1. 对栈而言，栈中的新加数据项放在其他数据的顶部，移除时也只能移除最顶部的数据（不能越位获取）。
2. 对堆而言，数据项位置没有固定的顺序。你可以以任何顺序插入和删除，因为他们没有“顶部”数据这一概念。

看一个简单的例子：

    int foo()
    {
        char *pBuffer; //<--nothing allocated yet (excluding the pointer itself, which is allocated here on the stack).
        bool b = true; // Allocated on the stack.
        if(b)
        {
            //Create 500 bytes on the stack
            char buffer[500];
    
            //Create 500 bytes on the heap
            pBuffer = new char[500];
    
        }//<-- buffer is deallocated here, pBuffer is not
    }//<--- oops there's a memory leak, I should have called delete[] pBuffer;

堆区，栈区的区别：

* 管理方式：对于栈来讲，是由编译器自动管理；对于堆来说，分配释放工作由程序员控制，容易造成内存泄露。
* 空间大小：一般来讲在32位系统下，堆内存可以达到4G的空间，从这个角度来看堆内存几乎是没有什么限制的。但是对于栈来讲，一般都是有一定的空间大小的。
* 碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题。
* 生长方向：对于堆来讲，向着内存地址增加的方向增长；对于栈来讲，向着内存地址减小的方向增长。
* 分配方式：堆都是动态分配（运行期）的，没有静态分配（编译期）的堆。栈有2种分配方式：静态分配和动态分配（alloca()函数可以动态分配栈的内存空间，释放的时候由编译器自己释放）。
* 分配效率：计算机在底层对栈提供支持，分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行，这就决定了栈的效率比较高。堆则是C/C++函数库提供的，它的机制是很复杂的，效率比栈要低得多。

［[栈空间分布，printf 函数参数](http://www.nowcoder.com/questionTerminal/b5e03f2361f04631b2eaf567029385c6)］ 

更多内容，参见 [Linux_OS_StackHeap.md](More/Linux_OS_StackHeap.md)

## 页面置换算法

常见的页面调度算法：

1. 随机算法rand（Random Algorithm）

    利用软件或硬件的随机数发生器来确定主存储器中被替换的页面。这种算法最简单，而且容易实现。但是，这种算法完全没用利用主存储器中页面调度情况的历史信息，也没有反映程序的局部性，所以命中率较低。
    
2. 先进先出调度算法（FIFO）

    先进先出调度算法根据页面进入内存的时间先后选择淘汰页面，本算法实现时需要将页面按进入内存的时间先后组成一个队列，每次调度队首页面予以淘汰。它的优点是比较容易实现，能够利用主存储器中页面调度情况的历史信息，但是，它没有反映程序的局部性，因为最先调入主存的页面，很可能也是经常要使用的页面。
    
3. 最近最少使用算法LRU（Least Recently Used Algorithm）

    根据程序执行的局部性特点，程序一旦访问了某些代码和数据，则在一段时间内会经常访问他们，因此最近最少使用在选择淘汰页面时会考虑页面最近的使用，总是选择在最近一段时间以来最少使用的页面予以淘汰。算法实现时需要为每个页面设置数据结构记录页面自上次访问以来所经历的时间。
    
4. 最近最不频繁使用算法 LFU（Least Frequently Used Algorithm ）
    
    由于程序设计中经常使用循环结构，根据程序执行的局部性特点，可以设想在一段时间内经常被访问的代码和数据在将来也会经常被访问，显然这样的页面不应该被淘汰。最近最不常用调度算法总是根据一段时间内页面的访问次数来选择淘汰页面，每次淘汰访问次数最少的页面。算法实现时需要为每个页面设置计数器，记录访问次数。计数器由硬件或操作系统自动定时清零。

［[LRU 缺页次数](http://www.nowcoder.com/questionTerminal/b6ba25af8c474d11909f756052f29c0e)］  
［[缺页率计算](http://www.nowcoder.com/questionTerminal/0a0e709f1c7343799c0194a1996ae202)］  
［[缺页替换影响效率](http://www.nowcoder.com/questionTerminal/40a2ed91959b4586b8a7255bbabdad7d)］  

## 主存、辅存、虚拟存储

概括的说，CPU对所需要的数据进行计算时，要求很高的存储速度，且不需要能永久保存这些数据，高速存储设备的成本很高。但其他设备对存储速度的要求不像CPU这么高，一般要求永久保存数据。一般低速的存储设备就可以满足，且低速的存储成本也低。

所以有主存和辅存之分： 

* 内存（主存）直接给CPU提供存储，高速，低容量，价格贵，不能永久保存数据，断电消失，需要从辅存中重新调入数据。  
* 外存（辅存）给主存提供数据，低速，大容量，价格低，能永久保存数据。

所以更高缓存的CPU和更大的内存能够大大提升系统的性能。 

* 常见主存有：CPU的高速缓存，电脑的内存条。
* 常见辅存有：硬盘、光盘、U盘、磁盘、移动硬盘等等。

`虚拟存储`：根据程序执行的互斥性和局部性两个特点，允许作业装入的时候只装入一部分，另一部分放在磁盘上，当需要的时候再装入到主存，这样以来，在一个小的主存空间就可以运行一个比它大的作业。同时，用户编程的时候也摆脱了一定要编写小于主存容量的作业的限制。也就是说，用户的逻辑地址空间可以比主存的绝对地址空间要大。**对用户来说，好像计算机系统具有一个容量很大的主存储器，称为“虚拟存储器”。**

虚拟存储（Storage Virtualization）是指将多个不同类型、独立存在的物理存储体，通过软、硬件技术，集成转化为一个逻辑上的虚拟的存储单元，集中管理供用户统一使用。这个虚拟逻辑存储单元的存储容量是它所集中管理的各物理存储体的存储量的总和，而它具有的访问带宽则在一定程度上接近各个物理存储体的访问带宽之和。

［[虚拟存储的目的](http://www.nowcoder.com/questionTerminal/8622d41af5f343c58ebbdf6e2e427ae3)］

## 内存存储模式

存储模型可以分为六种方式：

1. 单一连续区：一段时间内只能有一个进程在内存中，因此内存利用率低；
2. 固定分区：把内存空间分割成若干区域，成为分区，每个分区装载一个且只能有进程；
3. 可变分区：根据进程的需要，把内存空间分割出一个分区，分配给进程，剩余的部分成为新的空闲区。缺点：产生外部碎片，内存利用率低。
4. 页式存储：用户程序的地址空间被划分成若干固定大小的区域，称为“页”；相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。分页方式的优点是页长固定，因而便于构造页表、易于管理，且不存在外碎片。但分页方式的缺点是页长与程序的逻辑大小不相关。
5. 段式存储：将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻接，也实现了离散分配。
6. 段页式存储：段页式存储组织是分段式和分页式结合的存储组织方法，这样可充分利用分段管理和分页管理的优点。用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有自己的段名，再把每段分成固定大小的若干页。用分页方法来分配和管理实存。即把整个主存分成与上述页大小相等的存储块，可装入作业的任何一页。程序对内存的调入或调出是按页进行的。

更多内容参见 [Linux_OS_MemoryManage.md](More/Linux_OS_MemoryManage.md)

［[页表辅存始地址](http://www.nowcoder.com/questionTerminal/833de887bf7b438e9a96c1caf759c9da)］  

## Linux IO 模式

select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，实现单进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的（异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间）。

［[epoll和select](http://www.nowcoder.com/test/question/done?tid=2625399&qid=25654#summary)］

更多内容参见：
[Linux_OS_IO_Multiplexing.md](More/Linux_OS_IO_Model.md)

# 文件系统

更多内容参见 [Linux_OS_FileSystem.md](More/Linux_OS_FileSystem.md)

［[文件软链接描述](http://www.nowcoder.com/questionTerminal/232390b1b4e44464bbe58cba7a409d92)］  
［[磁盘存储优化](http://www.nowcoder.com/questionTerminal/c504ecac432d4fcd9c7a39edc79815bc)］  

## 两级缓存机制

为了兼顾速度和容量的问题，一般采用两级Cache结构，第一级Cache小而快，第二辑Cache容量大。

    平均的访问时间=命中时间(L1)+失效率(L1)*失效开销(L1)
                =命中时间(L1)+失效率(L1)*((命中时间(L2)+失效率(L2)*失效开销(L2))

［[两级缓存访问开销](http://www.nowcoder.com/questionTerminal/c0acab67e0794f3b84c0827f8bad6174)］
            
## RAID 工作模式

1. RAID 0：无差错控制的带区组
    
    要实现RAID0必须要有两个以上硬盘驱动器，RAID0实现了带区组，数据并不是保存在一个硬盘上，而是分成数据块保存在不同驱动器上。在所有的级别中，RAID 0的速度是最快的。但是RAID 0没有冗余功能的，如果一个磁盘(物理)损坏，则所有的数据都无法使用。

2. RAID 1：镜像结构

    当主硬盘损坏时，镜像硬盘就可以代替主硬盘工作。镜像硬盘相当于一个备份盘，可想而知，这种硬盘模式的安全性是非常高的，RAID 1的数据安全性在所有的RAID级别上来说是最好的。但是其磁盘的利用率却只有50%，是所有RAID级别中最低的。

3. RAID5：分布式奇偶校验的独立磁盘结构

    RAID5最大的好处是在一块盘掉线的情况下，RAID照常工作，相对于RAID0必须每一块盘都正常才可以正常工作的状况容错性能好多了。因此 RAID5是RAID级别中最常见的一个类型。RAID5校验位即P位是通过其它条带数据做异或(xor)求得的。计算公式为 P=D0xorD1xorD2…xorDn，其中p代表校验块，Dn代表相应的数据块，xor是数学运算符号异或。

4. RAID10：高可靠性与高效磁盘结构

    RAID 10是先镜像再分区数据。是将所有硬盘分为两组，视为是RAID 0的最低组合，然后将这两组各自视为RAID 1运作。RAID 10有着不错的读取速度，而且拥有比RAID 0更高的数据保护性。
    
参考： [RAID 工作模式](http://www.nowcoder.com/test/question/done?tid=2502355&qid=14636#summary)

## linux core文件
 
在一个程序崩溃时，它一般会在当前工作目录（或者指定目录）下生成一个core文件。core文件仅仅是一个内存映象(同时加上调试信息)，主要是用来调试的。

下面的命令可以检查生成core文件的选项是否打开:

    $ ulimit -a
    -c: core file size (blocks)         0

注意core file size是0，程序出错时不会产生core文件。可以用以下命令来允许系统生成core文件，并设定core文件最大大小:

    $ulimit -c 1024

使用gdb来查看core文件，可以指示出导致程序出错的代码所在文件和行数。

参考： [Linux生成core文件、core文件路径设置](http://www.nginx.cn/1521.html)

［[对应题目](http://www.nowcoder.com/test/question/done?tid=2503141&qid=14834#summary)］

## C++ 线程安全

`线程安全`就是多线程访问时，采用了加锁机制，当一个线程访问某个数据时，进行保护，其他线程不能进行访问直到该线程访问完毕，其他线程才可使用。不会出现数据不一致或者数据污染。线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。

线程安全问题都是由`全局变量`或者`静态变量`引起的。若每个线程中对全局变量、静态变量只有读操作，而无写操作，一般来说是线程安全的；若有多个线程同时执行写操作，一般都需要考虑线程同步，否则的话就可能影响线程安全。

C++ 中 volatile 关键字不能保证全局变量多线程安全，因为 volatile 仅仅是告诫compiler 不要对这个变量作优化，每次都要从 memory 取数值，而不是从register。

POSIX线程标准要求C标准库中的大多数函数具备线程安全性。C++标准库里面的string保证不是线程安全的。

［[对应题目](http://www.nowcoder.com/profile/509/test/2519469/3919#summary)］

参考：  
[线程安全和线程不安全理解](http://blog.csdn.net/ghevinn/article/details/37764791)

## Linux 用户权限管理

［[新建管理员用户](http://www.nowcoder.com/questionTerminal/43d2ccded19445b18ec61069416c299f)］


# 计算机组成原理

## Linux 启动流程

每个平台的启动细节不同，但整体来说启动过程如下。

首先 BIOS 加电自检，对硬件（内存，CPU，主板等）进行检测（POST: Power-On Self-Test）和初始化，因为操作系统的启动过程中可能会依赖于磁盘访问、屏幕、键盘等。（上个世纪70年代初，"只读内存"（read-only memory，缩写为ROM）发明，开机程序被刷入ROM芯片，计算机通电后，第一件事就是读取它。这块芯片里的程序叫做"基本输入输出系统"（Basic Input/Output System），简称为`BIOS`）

接下来BIOS按照"启动顺序"，把控制权转交给排在第一位的储存设备，读取该设备的第一个扇区（最前面的512个字节），即`主引导记录（MBR）`。主引导记录的主要作用是，告诉计算机到硬盘的哪一个位置去找操作系统。

主引导记录由三个部分组成：

1. 第1-446字节：调用操作系统的机器码（boot）。
2. 第447-510字节：分区表（Partition table）。
3. 第511-512字节：主引导记录签名（0x55和0xAA）。

MBR 中的 Boot Loader 程序被读入内存（0x7C00）后，首先将自身复制到高地址的内存（0x9000）当中从而为操作系统释放低地址的内存。Boot Loader 读取启动设备的根目录（这个工作通常由引导程序，如GRUB完成），读入操作系统，并把控制权交给内核。

内核的开始代码是用汇编语言写的，具有较高的机器依赖性。系统首先进行自动配置，一旦所有硬件配置完毕，就运行进程0，建立它的堆栈，运行它。进程0继续进行初始化：配置实时时钟，挂载根文件系统，创建 init 进程（进程1）和页面守护进程（进程2）。

然后，init线程加载系统的各个模块，比如窗口程序和网络程序，直至执行/bin/login程序，跳出登录界面，等待用户输入用户名和密码。

参考  
[计算机是如何启动的？](http://www.ruanyifeng.com/blog/2013/02/booting.html)  
[Linux 的启动流程](http://www.ruanyifeng.com/blog/2013/08/linux_boot_process.html)
  
## 数值的存储

正数的原码、反码、补码形式一致，负数的反码为原码的`数值位取反`，补码为反码+1也即是原码的数值位取反再+1，计算机中以补码表示数据和运算，而32位最小负整数的补码为 1000 0000 0000 0000 0000 0000 0000 0000。

对一个数值执行单目运算符 `-` 表示的是对该数取反然后再+1，也即是我们常说的`求补运算`，注意这里取反+1与原码求补码的区别！也就是求补运算与求补码是不一样的！

例子（4位有符号整数）：x=-4  1100（补码）   -x=~x+1 也即是 0011+0001=0100（4），而1100再求补码应是先数值位取反，即1011，然后+1，变成1100！注意这两者（求补与求补码）之间的区别。

［[－2^31 -1 的各种计算](http://www.nowcoder.com/questionTerminal/5f5f30bea94748fe903ff5616e73de00)］  
［[unsigned 取值](http://www.nowcoder.com/questionTerminal/3327439779e146dc9035b0977d9469eb)］

参考：  
[你不知道的按位运算](http://selfboot.cn/2015/09/23/something_about_bit_operation/)


# 分布式系统

分布式领域CAP理论：

* Consistency(一致性)，数据一致更新，所有数据变动都是同步的
* Availability(可用性)，好的响应性能
* Partition tolerance(分区容错性)：可靠性

定理：任何分布式系统只可同时满足二点，没法三者兼顾。
忠告：架构师不要将精力浪费在如何设计能满足三者的完美分布式 系统，而是应该进行取舍。

［[分布式系统三个指标](http://www.nowcoder.com/questionTerminal/3666684e8eb142369092da0a559925bb)］

# 其它

## awk、sed 简单使用

## 用户态、内核态

操作系统的很多操作会消耗系统的物理资源，例如创建一个新进程时，要做很多底层的工作，如分配物理内存，从父进程拷贝相关信息，拷贝设置页目录、页表等，这些操作显然不能让任何程序都可以做。

我们知道，Intel的 X86 架构的CPU提供了 0 到 3 四个特权级（在CPU的设计中，用户态指非特权状态。在此状态下，执行的代码被硬件限定，不能进行某些操作，比如写入其他进程的存储空间，以防止给操作系统带来安全隐患）。

在Linux操作系统操作系统的设计中主要采用了0和3两个特权级，也就是我们通常所说的内核态和用户态。运行于用户态的进程可以执行的操作和访问的资源都受到极大的限制，而运行于内核态的进程则可以执行任何操作并且在资源的使用上也没有限制。

当一个任务（进程）陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0 级）内核代码中执行。每个进程都有自己的内核栈和用户栈，当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。当进程在执行用户自己的代码时，则称其处于用户运行态（用户态），此时处理器在特权级最低的（3 级）用户代码中运行。简单来说在内核态下，CPU可执行任何指令，在用户态下CPU只能执行非特权指令。

Linux进程的 4GB 地址空间，3G-4G是内核态的地址空间，存放整个内核的代码和所有的内核模块，以及内核所维护的数据。用户运行一个程序，该程序所创建的进程运行在用户态，如果要执行文件操作，网络数据发送等操作，必须通过write，send等系统调用，这些系统调用会调用内核中的代码来完成操作。这时必须切换到Ring 0，然后进入3GB-4GB中的内核地址空间去执行这些代码完成操作，完成后切换回Ring 3，回到用户态。当程序处于内核态时可以随意进入用户态。
 
很多程序开始时运行于用户态，但在执行的过程中，一些操作需要在内核权限下才能执行，这就涉及到一个从用户态切换到内核态的过程。用户态切换到内核态的 3 种方式：

* `系统调用`：这是处于用户态的进程主动请求切换到内核态的一种方式。用户态的进程通过系统调用申请使用操作系统提供的系统调用服务例程来处理任务。
* `产生异常`：CPU执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会切换到内核态，如缺页异常。
* `外围设备的中断`：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换    

参考  
[linux用户态和内核态理解](http://blog.sina.com.cn/s/blog_4f9fc6e10102v0xb.html)  

## 标准库函数、系统调用

所有的操作系统都提供多种服务的入口点，由此程序向内核请求服务。各种版本的UNIX实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称为系统调用。简单来说，系统调用就是操作系统提供的用于实现系统各种核心功能的许多子程序，如 read()、write()、open()等

库函数顾名思义是把函数放到库里，是把一些常用到的函数编完放到一个文件里，供别人用。libc就是一个C标准库，里面存放一些基本函数，这些基本函数都是被标准化了的，而且这些函数通常都是用汇编直接实现的，如 printf、scanf等。

标准库函数构建在系统调用接口之上，应用程序既可以使用标准库函数，也可以使用系统调用。如下图：

![][3]

系统调用和标准库函数的区别如下：

* 从程序完成的功能来看，函数库提供的函数通常不需要操作系统的服务。系统调用是要求操作系统为用户提供某种服务，通常是涉及系统的硬件资源和一些敏感的软件资源等。
* 从程序执行的空间来说，标准库函数是在用户空间内执行的，除非函数涉及到I/O操作等，一般是不会切到内核态的。系统调用则运行于内核空间。
* 从程序的可移植性的角度来看，相对于系统调用，C语言的标准备函数库具备较高的可移植性。因为在所有的ANSI C编译器版本中，标准库函数是相同的；系统调用与系统有关，各个操作系统的系统调用是不同的。

［[系统调用函数](http://www.nowcoder.com/questionTerminal/06be659534644b8eb3f164f9f1085a9d)］  

参考  
[What is Linux System Calls and Library Functions?](http://www.thegeekstuff.com/2012/07/system-calls-library-functions/)  

## 共享内存的实现原理



##  可执行链接格式 ELF

ELF(Executable and Linking Format)是一种对象文件的格式，用于定义不同类型的对象文件(Object files)中都放了什么东西、以及都以什么样的格式去放这些东西。它最早在 System V 系统上出现后，被 xNIX 世界所广泛接受，作为缺省的二进制文件格式来使用。

ELF文件有三种类型： 

* 可重定位文件：也就是通常称的目标文件，后缀为.o。
* 共享文件：也就是通常称的库文件，后缀为.so。
* 可执行文件：


## 内存泄露检测

内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。

最难捉摸也最难检测到的错误之一是内存泄漏，即未能正确释放以前分配的内存的 bug。只发生一次的小的内存泄漏可能不会被注意，但泄漏大量内存的程序或泄漏日益增多的程序可能会表现出各种征兆：从性能不良（并且逐渐降低）到内存完全用尽。更糟的是，泄漏的程序可能会用掉太多内存，以致另一个程序失败，而使用户无从查找问题的真正根源。

内存泄漏的原因可以概括为：调用了malloc/new等内存申请的操作，但缺少了对应的free/delete，总之就是，malloc/new比free/delete的数量多。实际项目中检测内存泄漏通常会十分繁琐，所以有许多工具帮助我们检测内存泄漏，比如 [mtrace](http://en.wikipedia.org/wiki/Mtrace)，[valgrind](http://valgrind.org)。

详细内容参见 [Linux_OS_MemoryLeaks.md](More/Linux_OS_MemoryLeaks.md)

参考：  
[C/C++内存泄漏及检测](http://www.cnblogs.com/skynet/archive/2011/02/20/1959162.html)

# 更多阅读

《现代操作系统》  
[可执行链接格式 ELF](http://www.xfocus.net/articles/200109/260.html?cm_mc_uid=21124395775614576180143&cm_mc_sid_50200000=1461553081)  

[1]: http://7xrlu9.com1.z0.glb.clouddn.com/Linux_OS_1.jpg
[2]: http://7xrlu9.com1.z0.glb.clouddn.com/Linux_OS_2.jpg
[3]: http://7xrlu9.com1.z0.glb.clouddn.com/Linux_OS_3.png

